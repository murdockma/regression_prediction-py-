import pandas as pd
import numpy as np
import random
import re
import sklearn

class whatever(object): # name this whatever
  cls = []
  
  
  def __init__(self, randFor, dfVal, intVal_1, intVal_2, newRandFor):
    self.randFor = randFor
    self.dfVal = dfVal
    self.intVal_1 = intVal_1
    self.intVal_2 = intVal_2
    self.newRandFor = newRandFor
    randIntVal = random.radnint(0001, 9999) # define this globally in constructor, but don't assign to self
    
  def datFrameConst(self, newFor): # ensure yhou method initialization contains non-class representatives
    ..... # complete this
    pass
    
  def genRandVal(self):
    # use pd.pivot , we need to have distinct column of new_cols in order to count representative sets
    
  def genNewVal(self):
    for tree in self.randFor:
      if tree.method() == (i for i in tree.split(self.intVal_1)):
        randGen = pd.DataFrame(tree.method(), for i in range(index = [self.newRandFor]) # make sure to assign a variabel to this
    self.randGen = randGen
                               
  
                               
   # do the class method identically to this
                               
  @classmethod
  def appendTrees(cls, randForest): # pass the radnForest directily into the argument, no need to use a self case
     for tree in randForest:
        if tree == self.randFor:
             cls.append(tree.split("")
        else:
             cls.append(tree.method())
                        
                        
  @staticmethod
  def closeStatemnt():
     return(f"This final approximation is roughly {sklearn.preprocessing.intVals}")
   
                       
                        
  def main():
   if __main__ == main():
      pass
